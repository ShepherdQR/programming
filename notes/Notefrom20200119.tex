\documentclass[UTF8]{article}
\usepackage{ctex}
\usepackage{multirow,booktabs}
\usepackage{amsmath,amsthm,amsfonts,amssymb,bm,mathrsfs,upgreek} 
\usepackage[paper=a4paper,top=3.5cm,bottom=2.5cm,
left=2.7cm,right=2.7cm,
headheight=1.0cm,footskip=0.7cm]{geometry}
\usepackage{color,graphicx,verbatim}
\RequirePackage{setspace}%%ÐÐŒäŸà
\setstretch{1.523}

\begin{document}
Started on 2002011920:23

程序设计实习，北京大学，信息科学技术学院
郭炜，刘家瑛
*code： 代码
*question: 提出的问题


\section{c 相关}
\subsection{函数指针}
函数指针，指向函数起始地址
*code c0001
*code cpp0001

c语言快速排序函数：
void qsort(void *base, int nelem, unsigned int width, int(* pfCompare)(const void *, const void *));
这里面*pfCompare就是函数指针
起始地址，元素个数，每个元素大小，比较函数（自己编写）
int 比较函数(const void *elem1, const void *elem2);
比较函数编写，返回负整数会让elem1在前，返回正整数会让2在前，返回0则1和2不分前后。

\subsection{命令行参数}
2020012017:44,
win+R搜索cmd，
notepad t001.txt
copy file1.txt file2.txt

int main(int argc, char * argv[]){...}
argc,参数个数，>=1;
argv, 指针数组，argv[0]指向的字符串是第一个命令行参数，指向文件名，argv[i]指向i+1个命令行参数
打印所有命令行参数的程序*code c0003.c.

\subsection{位运算}
in comment
\begin{comment}
与&，双目,2个1才是1
21 & 18 = 16
某位清0，或提取变量某一位。
如将int低8位清0:
n = n & 0xffffff00;
n &= 0xffffff00;
对于short的n是 n &= 0xff00;
*question: 判断int右起从0开始第7位是否是1？
看n & 0x80 是不是0x80即可。
0x80 = 1000 0000 。


或|，双目,2个0才是0
21 | 18 = 23
某些位置1，保留其余不变，
如低8位变成1其余不变，
n |= 0xffffffea



非~，单目,
~21 = 0xff



异或^，双目, 不同时取1.
21 ^ 18 = 7
某些位取反，其余不变。
n ^= 0xff
1 1 0
0 0 0
1 0 1
0 1 1
发现 a^b=c,能得到b^c=a, c^a=b, 可用于加密解密，如用秘钥b加密a。
a b --c | a b -a
b c --a | b a -b
c a --b | a b -a
如以下可实现2个变量直接交换：
a ^= b;
b ^= a;
a ^= b;


<<左移，双目
a<<b = a*2^b
a左移b位，高位丢弃，低位补0


>>右移，双目
有符号位如long, int, short, char, 右移后左边补的数和符号位相同。
无符号的补0
往小取整
-25 >> 4 = -2
-2 >> 4 = -1
18 >> 4 = 1
*code c0004

*question: 2个int的a和n=[0,31],取a的第n位。
(a>>n) & 0x0001;
(a>>n) & 1;
或者： (a & (1<<n))>> n
\end{comment}

\subsection{引用和常量}
in comment
% const T & 可以初始化 T &，反过来不行
\begin{comment}
const int MAX_VAL = 23;
const double Pi = 3.14;
const char * schol_name = "mit";

1）不能通过const指针修改其所指向的内容；
2）常量指针不能赋值给非常量指针，除非强制类型转换(int *),反过来可以。
3）函数中const能防止参数指针指向的地方的数据被修改
void MyPrintf( const char *p){
    strcpy(p," by QR");//编译应该会出错
    printf("%s\n",p);
}

\end{comment}

\subsection{动态内存分配}
in comment
2020012822:19
\begin{comment}

malloc库
P = new T;
T是任意类型名，P是T*的指针，是动态分配出sizeof(T)的内存空间的起始地址。
int *pnew;
pnew = new int;
*pnew = 5;
delete pnew;

P = new T[n];
n是元素个数或者整数表达式
int *p;
int n = 6;
pnew = new int[n * 20];
pnew[0] = 20;
pnew[100] = 30;//编译没问题，运行会数组越界。
delete []pnew;

int *pnew = new int;

delete pnew; // 释放。delete 跟的指针要是一片动态空间
不释放的空间在程序运行期间会一直占用。


int *pnew = new int; *pnew = 5; delete pnew;
int *p_ = new int[6]; *p_[0] = 6; delete [] p_;

\end{comment}



\subsection{内联函数和函数重载}
in comment
2020012822:19
\begin{comment}
减少函数调用的开销，把函数插入到调用语句处。exe文件大
inline int max(int a, int b){
    if (a>b) return a;
    return b;
}
小的函数，调用时和执行过程产生的开销差不多。
函数名相同， 参数个数和类型不同叫参数重载,c++可以名字相同参数类型不同就好
int max(int a, int b){...;}
int max(int a, int b, int c){...;}
int max(double a, double b){...;}
名字和参数表相同的函数即使返回值类型不同也是重定义是错误
\end{comment}



\subsection{函数的缺省参数}
in comment
2020012822:19
\begin{comment}
最右边的若干连续参数可以缺省
void func(int x1, int x2 = 2, int x3 = 3){}
用处在于函数添加新参数时不需要修改原来不用新参数的对函数的调用。比如说原来写的单色的绘图函数加上可选颜色的属性。


\end{comment}











\end{document}