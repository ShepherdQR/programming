\documentclass[UTF8]{article}
\usepackage{ctex}
\usepackage{multirow,booktabs}
\usepackage{amsmath,amsthm,amsfonts,amssymb,bm,mathrsfs,upgreek} 
\usepackage[paper=a4paper,top=3.5cm,bottom=2.5cm,
left=2.7cm,right=2.7cm,
headheight=1.0cm,footskip=0.7cm]{geometry}
\usepackage{color,graphicx,verbatim}
\RequirePackage{setspace}%%ÐÐŒäŸà
\setstretch{1.523}

\begin{document}
Started on 2002011920:23

程序设计实习，北京大学，信息科学技术学院
郭炜，刘家瑛
*code： 代码
*question: 提出的问题


\section{基础包括c等}
\subsection{函数指针}
函数指针，指向函数起始地址
*code c0001
*code cpp0001

c语言快速排序函数：
void qsort(void *base, int nelem, unsigned int width, int(* pfCompare)(const void *, const void *));
这里面*pfCompare就是函数指针
起始地址，元素个数，每个元素大小，比较函数（自己编写）
int 比较函数(const void *elem1, const void *elem2);
比较函数编写，返回负整数会让elem1在前，返回正整数会让2在前，返回0则1和2不分前后。

\subsection{命令行参数}
2020012017:44,
win+R搜索cmd，
notepad t001.txt
copy file1.txt file2.txt

int main(int argc, char * argv[]){...}
argc,参数个数，>=1;
argv, 指针数组，argv[0]指向的字符串是第一个命令行参数，指向文件名，argv[i]指向i+1个命令行参数
打印所有命令行参数的程序*code c0003.c.

\subsection{位运算}
in comment
\begin{comment}
与&，双目,2个1才是1
21 & 18 = 16
某位清0，或提取变量某一位。
如将int低8位清0:
n = n & 0xffffff00;
n &= 0xffffff00;
对于short的n是 n &= 0xff00;
*question: 判断int右起从0开始第7位是否是1？
看n & 0x80 是不是0x80即可。
0x80 = 1000 0000 。


或|，双目,2个0才是0
21 | 18 = 23
某些位置1，保留其余不变，
如低8位变成1其余不变，
n |= 0xffffffea



非~，单目,
~21 = 0xff



异或^，双目, 不同时取1.
21 ^ 18 = 7
某些位取反，其余不变。
n ^= 0xff
1 1 0
0 0 0
1 0 1
0 1 1
发现 a^b=c,能得到b^c=a, c^a=b, 可用于加密解密，如用秘钥b加密a。
a b --c | a b -a
b c --a | b a -b
c a --b | a b -a
如以下可实现2个变量直接交换：
a ^= b;
b ^= a;
a ^= b;


<<左移，双目
a<<b = a*2^b
a左移b位，高位丢弃，低位补0


>>右移，双目
有符号位如long, int, short, char, 右移后左边补的数和符号位相同。
无符号的补0
往小取整
-25 >> 4 = -2
-2 >> 4 = -1
18 >> 4 = 1
*code c0004

*question: 2个int的a和n=[0,31],取a的第n位。
(a>>n) & 0x0001;
(a>>n) & 1;
或者： (a & (1<<n))>> n
\end{comment}

\subsection{引用和常量}
in comment
% const T & 可以初始化 T &，反过来不行
\begin{comment}
const int MAX_VAL = 23;
const double Pi = 3.14;
const char * schol_name = "mit";

1）不能通过const指针修改其所指向的内容；
2）常量指针不能赋值给非常量指针，除非强制类型转换(int *),反过来可以。
3）函数中const能防止参数指针指向的地方的数据被修改
void MyPrintf( const char *p){
    strcpy(p," by QR");//编译应该会出错
    printf("%s\n",p);
}

\end{comment}

\subsection{动态内存分配}
in comment
2020012822:19
\begin{comment}

malloc库
P = new T;
T是任意类型名，P是T*的指针，是动态分配出sizeof(T)的内存空间的起始地址。
int *pnew;
pnew = new int;
*pnew = 5;
delete pnew;

P = new T[n];
n是元素个数或者整数表达式
int *p;
int n = 6;
pnew = new int[n * 20];
pnew[0] = 20;
pnew[100] = 30;//编译没问题，运行会数组越界。
delete []pnew;

int *pnew = new int;

delete pnew; // 释放。delete 跟的指针要是一片动态空间
不释放的空间在程序运行期间会一直占用。


int *pnew = new int; *pnew = 5; delete pnew;
int *p_ = new int[6]; *p_[0] = 6; delete [] p_;

\end{comment}



\subsection{内联函数和函数重载}
in comment
2020012822:19
\begin{comment}
减少函数调用的开销，把函数插入到调用语句处。exe文件大
inline int max(int a, int b){
    if (a>b) return a;
    return b;
}
小的函数，调用时和执行过程产生的开销差不多。
函数名相同， 参数个数和类型不同叫参数重载,c++可以名字相同参数类型不同就好
int max(int a, int b){...;}
int max(int a, int b, int c){...;}
int max(double a, double b){...;}
名字和参数表相同的函数即使返回值类型不同也是重定义是错误
\end{comment}



\subsection{函数的缺省参数}
in comment
2020012822:19
\begin{comment}
最右边的若干连续参数可以缺省
void func(int x1, int x2 = 2, int x3 = 3){}
用处在于函数添加新参数时不需要修改原来不用新参数的对函数的调用。比如说原来写的单色的绘图函数加上可选颜色的属性。

\end{comment}



\section{结构化程序设计}
in comment
**code cpp0004
2020013016:34
大问题分解也就是模块化得到若干子问题。
pascal语言发明人worth提出 程序=数据结构+算法。
程序：理解、修改、差错、重用四大难点。
分析问题所含事物及事物之间的关系，
面向对象的程序 = 类+类。。。同一类事物的共同属性抽象为数据结构，行为抽象为函数。
事物抽象成类，数据结构和操作数据结构的算法封装成类。class包含data和function



程序设计语言历史：
1960年算法描述语言，ALGOL60
1963年，剑桥大学发展 CPL，
1967年，剑桥大学 BCPL，
1967年，Simula 67，第一个面向对象的语言，提出类、子类等概念
1970年，贝尔实验室，B语言，
1971，Smalltalk
1973年，C语言，
1983年，C++，更适合面向对象。
1995，JAVA，
%2003，微软开发C#


常用c++编译器：
GCC，visual c++，dev c， eclipse， borand c++Builder

2020013118:41
成员变量和成员函数
== != > < >= <= 需要重载后才可以进行对象之间的比较

对象名.成员名
指针->成员名


类成员可访问范围：
private, 成员函数内，意义在于强制限制只用成员函数访问该变量
public，任何地方
protected
省缺时默认为私有
类的成员函数可以访问当前对象和同类其他对象的全部属性和函数，而成员函数外的地方只能访问该类对象的公有成员
\begin{comment}

\end{comment}



\end{document}